# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['entrada', 'greedy', 'vecindario', 'f', 'new_best', 'update_T']

# Cell
def entrada(N):
    """ Leer matriz de distancias.
    Recibe: número de ciudades, N.
    Regresa: matriz de distancias completa. """
    costos = [[0]*N for i in range(N)]
    for n in range(N-1):
        n_cost = list(map(int,input().split()))
        column = n+1
        for i in range(len(n_cost)):
            costos[n][column] = n_cost[i]
            costos[column][n] = n_cost[i]
            column+=1
    return costos

# Cell
def greedy(N,C):
    """ Función Greedy para encontrar la solución inicial.
    Recibe: número de ciudades, N; matriz de costos, C.
    Regresa: costo total de la solución encontrada, solución encontrada. """
    sol = [0]
    tot_cost = 0
    mini = max(C[0])
    city = 0
    next_city = 0
    while len(sol) < N:
        city = sol[-1]
        mini = max(C[city])
        for this_city in range(N):
            if city != this_city and this_city not in sol:
                costo = C[city][this_city]
                if costo < mini:
                    mini = costo
                    next_city = this_city
        tot_cost += mini
        sol.append(next_city)
    tot_cost += C[0][next_city]
    return tot_cost, sol

# Cell
def vecindario(N,x,T):
    """ Función para crear el vecindario o conjunto de nuevas soluciones candidatas.
    Recibe: número de ciudades, N; solución x_k, x; lista Taboo, T.
    Regresa: ciudad utilizada para crear el vecindario, vecindario.
    """
    sols = []
    semilla = random.choice(range(1,N))
    while True:
        if x[semilla] in T:
            semilla = random.choice(range(1,N))
        else:
            break
    for ns in range(1,N):
        if ns != semilla:
            sol = copy.copy(x)
            sol[ns],sol[semilla] = sol[semilla],sol[ns]
            sols.append(sol)
    return x[semilla], sols

# Cell
def f(x):
    """ Función para evaluar la solución x_k.
    Recibe: solución x_k, x.
    Regresa: costo de la solución.
    """
    city = 0
    costo = 0
    for n_city in range(1,N):
        costo += mat_cost[x[city]][x[n_city]]
        city += 1
    costo += mat_cost[x[-1]][x[0]]
    return costo

# Cell
def new_best(best,V):
    """ Función para determinar la mejor solución del vecindario.
    Recibe: la mejor solución hasta ahora, best; el vecindario, V.
    Regresa: la nueva mejor solución.
    """
    for x in V:
        f_1 = f(x)
        f_2 = f(best)
        if f_1 < f_2:
            best = x
    return best

# Cell
def update_T(T):
    """ Funcipo para actualizar la lista Taboo.
    Recibe: la lista Taboo, T.
    Regresa: la lista Taboo actualizada.
    """
    to_pop = []
    for key in T:
        if T[key]-1 == 0:
            to_pop.append(key)
        else:
            T[key]-=1
    for key in to_pop:
        T.pop(key)
    T[new_T] = N//2
    return T